package main

import (
	"encoding/binary"
	"fmt"
	"os"

	"github.com/ethereum/go-ethereum/crypto"
)

func main() {
	// How many bits do we want to break?
	bits := 16

	// the public key is 64 bytes long, so that's the input to the hash
	input := make([]byte, 64) // 64 bytes is the discv4 public key length

	// the resulting hash, which is used to determine peer closeness, is 32 bytes long
	output := make([]byte, 32) // 32 bytes is the key length in the Kademlia keyspace

	// How many prefixes do we need to find?
	totalPrefixes := 1 << bits // 2^bits

	// How many prefixes have we found?
	foundPrefixesCount := 0

	// Here we store the preimage for a given prefix
	preimages := make([]uint32, totalPrefixes)

	// Here we keep track which prefixes we've already found.
	foundPrefixes := make([]bool, totalPrefixes)

	// Which hash function do we want to use?
	hasher := crypto.NewKeccakState()

	fmt.Println("breaking prefixes...")
	for i := uint32(0); foundPrefixesCount < totalPrefixes; i++ {
		// put the current number into the input byte slice
		binary.BigEndian.PutUint32(input[:], i)

		// hash the input byte slice and store it in the output
		hasher.Write(input[:])
		output = hasher.Sum(output[:0]) // reuse existing output slice
		hasher.Reset()

		// Only take the "bits"
		prefix := binary.BigEndian.Uint32(output) >> (32 - bits)

		// if we know this prefix already, continue with the next number
		if foundPrefixes[prefix] {
			continue
		}

		foundPrefixes[prefix] = true
		preimages[prefix] = i
		foundPrefixesCount += 1
	}

	fmt.Println("writing prefixes...")
	f, err := os.Create("discv4/prefixmap.go")
	if err != nil {
		panic(err)
	}

	printf := func(s string, args ...interface{}) {
		_, err = fmt.Fprintf(f, s, args...)
		if err != nil {
			panic(err)
		}
	}

	printf("package %s\n\n", "discvx")
	printf("// Code generated by gen.go DO NOT EDIT\n")
	printf("var keyPrefixMap = [...]uint32{")
	for i, j := range preimages[:] {
		if i%16 == 0 { // 16 prefixes per line in the output file
			printf("\n\t")
		} else {
			printf(" ")
		}
		printf("%d,", j)
	}
	printf("\n}")
	if err = f.Close(); err != nil {
		panic(err)
	}

	fmt.Println("done")
}
